1.
source: class GameMenu line 69-73 & line 212-216 dan enum Mode
smell: missing abstraction
problem: menggunakan string untuk label player yang bergantung dengan mode yang dipilih, apabila dikemudian
hari ada mode computer vs computer maka akan ada if tambahan lagi di class GameMenu
solution: membuat abstraction class untuk class Mode, dan subclass VersusPlayerMode dan VersusComputerMode
dan method abstract untuk dipakai di subclass mode-modenya

2.
source: class HowToPlayMenu
smell: imperative abstraction
problem: imperative abstraction terjadi ketika sebuah operasi dibuat menjadi sebuah class,
dan di dalam class ini, hanya punya satu method saja
solution: memindahkan method dalam class HowToPlayMenu ke class MainMenu

3.
source: class PlayerMenu
smell: Multifaceted Abstraction
problem: class ini memiliki lebih dari satu tanggung jawab melanggar SRP. Class ini bertanggung jawab
atas pembuatan player biasa dan player computer dan juga bertanggung jawab atas menampilkan player menu
solution: membuat parent Character menu dan membuat class baru bernama ComputerMenu, mengubah access
modifier dari attribut player dan mainmenu dari private jadi protected agar bisa digunakan oleh subclassnya
lalu membuat abstract function create untuk pembuatan player/computer

4.
source: class Solution, attribute arraylist picks dan int result
smell: deficient encapsulation
problem: access modifier attributenya public
solution: bikin access modifiernya menjadi private dan tambahkan fungsi getter dan constructor, lalu agar tidak terjadi
leaky saat getter list, maka kita melakukan deep copy untuk getter listnya

5.
source: class GameState, attribute player dan computer
smell: deficient encapsulation
problem: access modifier attributenya public
solution: bikin access modifiernya menjadi private dan tambahkan fungsi getter

6.
source: class Computer, attribute picks and solution
smell: deficient encapsulation
problem: access modifier attributenya public
solution: bikin access modifiernya menjadi private dan tambahkan fungsi getter, dan tambahkan deep copy agar
tidak terjadi leaky saat get queue dan list.

7.
source: class MainMenu dan class HowToPlayMenu
smell: Cyclically-Dependent Modularization
problem: terjadi dikarenakan main menu dan HowToPlayMenu saling memiliki dependency satu sama lain
solution: memindahkan method yang atau attribut yang memiliki depedency ke class lainnya. Pada kasus ini saya memindahkan
method print yang terdapat dalam HowToPlayMenu ke class MainMenu, sehingga class MainMenu tidak memerlukan atau tidak
ada depedency dengan class HowToPlayMenu lagi.

7.
source: class MainMenu dan class GameMenu
smell: Cyclically-Dependent Modularization
problem: terjadi dikarenakan class MainMenu dan GameMenu saling memiliki dependency satu sama lain (class MainMenu
memiliki attribut GameMenu dan class GameMenu mempunyai attribut MainMenu)
solution: menghapus attribute GameMenu pada MainMenu dikarenakan attribute tersebut sama sekali tidak digunakan karena
pada switch casenya kita sekedar hanya ingin men-trigger constructor dari class GameMenu